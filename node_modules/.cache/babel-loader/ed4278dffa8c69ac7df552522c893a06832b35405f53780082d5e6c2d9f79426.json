{"ast":null,"code":"// src/index.ts\nfunction getMinValueAtIndex(index, values, minValue) {\n  return index === 0 ? minValue : values[index - 1];\n}\nfunction getMaxValueAtIndex(index, values, maxValue) {\n  return index === values.length - 1 ? maxValue : values[index + 1];\n}\nfunction isValueAtMax(value, maxValue) {\n  return value >= maxValue;\n}\nfunction isValueAtMin(value, minValue) {\n  return value <= minValue;\n}\nfunction isValueWithinRange(value, minValue, maxValue) {\n  return value >= minValue && value <= maxValue;\n}\nfunction getRoundedValue(value, minValue, step) {\n  return Math.round((value - minValue) / step) * step + minValue;\n}\nfunction clampValue(value, minValue, maxValue) {\n  return Math.min(Math.max(value, minValue), maxValue);\n}\nfunction getValuePercent(value, minValue, maxValue) {\n  return (value - minValue) / (maxValue - minValue);\n}\nfunction getPercentValue(percent, minValue, maxValue, step) {\n  const value = percent * (maxValue - minValue) + minValue;\n  const roundedValue = getRoundedValue(value, minValue, step);\n  return clampValue(roundedValue, minValue, maxValue);\n}\nfunction roundToStepPrecision(value, step) {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf(\".\");\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\nfunction snapValueToStep(value, min, max, step) {\n  min = Number(min);\n  max = Number(max);\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;\n  }\n  snappedValue = roundToStepPrecision(snappedValue, step);\n  return snappedValue;\n}\nfunction setValueAtIndex(values, index, value) {\n  if (values[index] === value) return values;\n  return [...values.slice(0, index), value, ...values.slice(index + 1)];\n}\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getClosestValueIndex(values, targetValue) {\n  let targetIndex = values.findIndex(value => targetValue - value < 0);\n  if (targetIndex === 0) {\n    return targetIndex;\n  }\n  if (targetIndex === -1) {\n    return values.length - 1;\n  }\n  let valueBefore = values[targetIndex - 1];\n  let valueAfter = values[targetIndex];\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1;\n  }\n  return targetIndex;\n}\nfunction getValueRanges(values, minValue, maxValue, gap) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap;\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap;\n    return {\n      min,\n      max,\n      value\n    };\n  });\n}\nfunction getValueTransformer(valueA, valueB) {\n  const input = {\n    min: valueA[0],\n    max: valueA[1]\n  };\n  const output = {\n    min: valueB[0],\n    max: valueB[1]\n  };\n  return function getValue(value) {\n    if (input.min === input.max || output.min === output.max) return output.min;\n    const ratio = (output.max - output.min) / (input.max - input.min);\n    return output.min + ratio * (value - input.min);\n  };\n}\nfunction toFixedNumber(value, digits = 0, base = 10) {\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\nfunction mod(value, modulo) {\n  return (value % modulo + modulo) % modulo;\n}\nexport { clampValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getRoundedValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, isValueAtMax, isValueAtMin, isValueWithinRange, mod, roundToStepPrecision, snapValueToStep, toFixedNumber };","map":{"version":3,"names":["getMinValueAtIndex","index","values","minValue","getMaxValueAtIndex","maxValue","length","isValueAtMax","value","isValueAtMin","isValueWithinRange","getRoundedValue","step","Math","round","clampValue","min","max","getValuePercent","getPercentValue","percent","roundedValue","roundToStepPrecision","stepString","toString","pointIndex","indexOf","precision","pow","snapValueToStep","Number","remainder","isNaN","snappedValue","abs","sign","floor","setValueAtIndex","slice","getValueSetterAtIndex","ctx","minValueAtIndex","maxValueAtIndex","nextValues","setValue","nextValue","getNextStepValue","getPreviousStepValue","getClosestValueIndex","targetValue","targetIndex","findIndex","valueBefore","valueAfter","getValueRanges","gap","map","getValueTransformer","valueA","valueB","input","output","getValue","ratio","toFixedNumber","digits","base","mod","modulo"],"sources":["D:/assignment/e_commerce/ecommerce-product-page/node_modules/@zag-js/numeric-range/dist/index.mjs"],"sourcesContent":["// src/index.ts\nfunction getMinValueAtIndex(index, values, minValue) {\n  return index === 0 ? minValue : values[index - 1];\n}\nfunction getMaxValueAtIndex(index, values, maxValue) {\n  return index === values.length - 1 ? maxValue : values[index + 1];\n}\nfunction isValueAtMax(value, maxValue) {\n  return value >= maxValue;\n}\nfunction isValueAtMin(value, minValue) {\n  return value <= minValue;\n}\nfunction isValueWithinRange(value, minValue, maxValue) {\n  return value >= minValue && value <= maxValue;\n}\nfunction getRoundedValue(value, minValue, step) {\n  return Math.round((value - minValue) / step) * step + minValue;\n}\nfunction clampValue(value, minValue, maxValue) {\n  return Math.min(Math.max(value, minValue), maxValue);\n}\nfunction getValuePercent(value, minValue, maxValue) {\n  return (value - minValue) / (maxValue - minValue);\n}\nfunction getPercentValue(percent, minValue, maxValue, step) {\n  const value = percent * (maxValue - minValue) + minValue;\n  const roundedValue = getRoundedValue(value, minValue, step);\n  return clampValue(roundedValue, minValue, maxValue);\n}\nfunction roundToStepPrecision(value, step) {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf(\".\");\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\nfunction snapValueToStep(value, min, max, step) {\n  min = Number(min);\n  max = Number(max);\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = roundToStepPrecision(\n    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,\n    step\n  );\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;\n  }\n  snappedValue = roundToStepPrecision(snappedValue, step);\n  return snappedValue;\n}\nfunction setValueAtIndex(values, index, value) {\n  if (values[index] === value) return values;\n  return [...values.slice(0, index), value, ...values.slice(index + 1)];\n}\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getClosestValueIndex(values, targetValue) {\n  let targetIndex = values.findIndex((value) => targetValue - value < 0);\n  if (targetIndex === 0) {\n    return targetIndex;\n  }\n  if (targetIndex === -1) {\n    return values.length - 1;\n  }\n  let valueBefore = values[targetIndex - 1];\n  let valueAfter = values[targetIndex];\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1;\n  }\n  return targetIndex;\n}\nfunction getValueRanges(values, minValue, maxValue, gap) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap;\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap;\n    return { min, max, value };\n  });\n}\nfunction getValueTransformer(valueA, valueB) {\n  const input = { min: valueA[0], max: valueA[1] };\n  const output = { min: valueB[0], max: valueB[1] };\n  return function getValue(value) {\n    if (input.min === input.max || output.min === output.max) return output.min;\n    const ratio = (output.max - output.min) / (input.max - input.min);\n    return output.min + ratio * (value - input.min);\n  };\n}\nfunction toFixedNumber(value, digits = 0, base = 10) {\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\nfunction mod(value, modulo) {\n  return (value % modulo + modulo) % modulo;\n}\n\nexport { clampValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getRoundedValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, isValueAtMax, isValueAtMin, isValueWithinRange, mod, roundToStepPrecision, snapValueToStep, toFixedNumber };\n"],"mappings":"AAAA;AACA,SAASA,kBAAkBA,CAACC,KAAK,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACnD,OAAOF,KAAK,KAAK,CAAC,GAAGE,QAAQ,GAAGD,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC;AACnD;AACA,SAASG,kBAAkBA,CAACH,KAAK,EAAEC,MAAM,EAAEG,QAAQ,EAAE;EACnD,OAAOJ,KAAK,KAAKC,MAAM,CAACI,MAAM,GAAG,CAAC,GAAGD,QAAQ,GAAGH,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC;AACnE;AACA,SAASM,YAAYA,CAACC,KAAK,EAAEH,QAAQ,EAAE;EACrC,OAAOG,KAAK,IAAIH,QAAQ;AAC1B;AACA,SAASI,YAAYA,CAACD,KAAK,EAAEL,QAAQ,EAAE;EACrC,OAAOK,KAAK,IAAIL,QAAQ;AAC1B;AACA,SAASO,kBAAkBA,CAACF,KAAK,EAAEL,QAAQ,EAAEE,QAAQ,EAAE;EACrD,OAAOG,KAAK,IAAIL,QAAQ,IAAIK,KAAK,IAAIH,QAAQ;AAC/C;AACA,SAASM,eAAeA,CAACH,KAAK,EAAEL,QAAQ,EAAES,IAAI,EAAE;EAC9C,OAAOC,IAAI,CAACC,KAAK,CAAC,CAACN,KAAK,GAAGL,QAAQ,IAAIS,IAAI,CAAC,GAAGA,IAAI,GAAGT,QAAQ;AAChE;AACA,SAASY,UAAUA,CAACP,KAAK,EAAEL,QAAQ,EAAEE,QAAQ,EAAE;EAC7C,OAAOQ,IAAI,CAACG,GAAG,CAACH,IAAI,CAACI,GAAG,CAACT,KAAK,EAAEL,QAAQ,CAAC,EAAEE,QAAQ,CAAC;AACtD;AACA,SAASa,eAAeA,CAACV,KAAK,EAAEL,QAAQ,EAAEE,QAAQ,EAAE;EAClD,OAAO,CAACG,KAAK,GAAGL,QAAQ,KAAKE,QAAQ,GAAGF,QAAQ,CAAC;AACnD;AACA,SAASgB,eAAeA,CAACC,OAAO,EAAEjB,QAAQ,EAAEE,QAAQ,EAAEO,IAAI,EAAE;EAC1D,MAAMJ,KAAK,GAAGY,OAAO,IAAIf,QAAQ,GAAGF,QAAQ,CAAC,GAAGA,QAAQ;EACxD,MAAMkB,YAAY,GAAGV,eAAe,CAACH,KAAK,EAAEL,QAAQ,EAAES,IAAI,CAAC;EAC3D,OAAOG,UAAU,CAACM,YAAY,EAAElB,QAAQ,EAAEE,QAAQ,CAAC;AACrD;AACA,SAASiB,oBAAoBA,CAACd,KAAK,EAAEI,IAAI,EAAE;EACzC,IAAIS,YAAY,GAAGb,KAAK;EACxB,IAAIe,UAAU,GAAGX,IAAI,CAACY,QAAQ,CAAC,CAAC;EAChC,IAAIC,UAAU,GAAGF,UAAU,CAACG,OAAO,CAAC,GAAG,CAAC;EACxC,IAAIC,SAAS,GAAGF,UAAU,IAAI,CAAC,GAAGF,UAAU,CAACjB,MAAM,GAAGmB,UAAU,GAAG,CAAC;EACpE,IAAIE,SAAS,GAAG,CAAC,EAAE;IACjB,IAAIC,GAAG,GAAGf,IAAI,CAACe,GAAG,CAAC,EAAE,EAAED,SAAS,CAAC;IACjCN,YAAY,GAAGR,IAAI,CAACC,KAAK,CAACO,YAAY,GAAGO,GAAG,CAAC,GAAGA,GAAG;EACrD;EACA,OAAOP,YAAY;AACrB;AACA,SAASQ,eAAeA,CAACrB,KAAK,EAAEQ,GAAG,EAAEC,GAAG,EAAEL,IAAI,EAAE;EAC9CI,GAAG,GAAGc,MAAM,CAACd,GAAG,CAAC;EACjBC,GAAG,GAAGa,MAAM,CAACb,GAAG,CAAC;EACjB,IAAIc,SAAS,GAAG,CAACvB,KAAK,IAAIwB,KAAK,CAAChB,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAG,CAAC,IAAIJ,IAAI;EACvD,IAAIqB,YAAY,GAAGX,oBAAoB,CACrCT,IAAI,CAACqB,GAAG,CAACH,SAAS,CAAC,GAAG,CAAC,IAAInB,IAAI,GAAGJ,KAAK,GAAGK,IAAI,CAACsB,IAAI,CAACJ,SAAS,CAAC,IAAInB,IAAI,GAAGC,IAAI,CAACqB,GAAG,CAACH,SAAS,CAAC,CAAC,GAAGvB,KAAK,GAAGuB,SAAS,EACjHnB,IACF,CAAC;EACD,IAAI,CAACoB,KAAK,CAAChB,GAAG,CAAC,EAAE;IACf,IAAIiB,YAAY,GAAGjB,GAAG,EAAE;MACtBiB,YAAY,GAAGjB,GAAG;IACpB,CAAC,MAAM,IAAI,CAACgB,KAAK,CAACf,GAAG,CAAC,IAAIgB,YAAY,GAAGhB,GAAG,EAAE;MAC5CgB,YAAY,GAAGjB,GAAG,GAAGH,IAAI,CAACuB,KAAK,CAACd,oBAAoB,CAAC,CAACL,GAAG,GAAGD,GAAG,IAAIJ,IAAI,EAAEA,IAAI,CAAC,CAAC,GAAGA,IAAI;IACxF;EACF,CAAC,MAAM,IAAI,CAACoB,KAAK,CAACf,GAAG,CAAC,IAAIgB,YAAY,GAAGhB,GAAG,EAAE;IAC5CgB,YAAY,GAAGpB,IAAI,CAACuB,KAAK,CAACd,oBAAoB,CAACL,GAAG,GAAGL,IAAI,EAAEA,IAAI,CAAC,CAAC,GAAGA,IAAI;EAC1E;EACAqB,YAAY,GAAGX,oBAAoB,CAACW,YAAY,EAAErB,IAAI,CAAC;EACvD,OAAOqB,YAAY;AACrB;AACA,SAASI,eAAeA,CAACnC,MAAM,EAAED,KAAK,EAAEO,KAAK,EAAE;EAC7C,IAAIN,MAAM,CAACD,KAAK,CAAC,KAAKO,KAAK,EAAE,OAAON,MAAM;EAC1C,OAAO,CAAC,GAAGA,MAAM,CAACoC,KAAK,CAAC,CAAC,EAAErC,KAAK,CAAC,EAAEO,KAAK,EAAE,GAAGN,MAAM,CAACoC,KAAK,CAACrC,KAAK,GAAG,CAAC,CAAC,CAAC;AACvE;AACA,SAASsC,qBAAqBA,CAACtC,KAAK,EAAEuC,GAAG,EAAE;EACzC,MAAMC,eAAe,GAAGzC,kBAAkB,CAACC,KAAK,EAAEuC,GAAG,CAACtC,MAAM,EAAEsC,GAAG,CAACxB,GAAG,CAAC;EACtE,MAAM0B,eAAe,GAAGtC,kBAAkB,CAACH,KAAK,EAAEuC,GAAG,CAACtC,MAAM,EAAEsC,GAAG,CAACvB,GAAG,CAAC;EACtE,IAAI0B,UAAU,GAAGH,GAAG,CAACtC,MAAM,CAACoC,KAAK,CAAC,CAAC;EACnC,OAAO,SAASM,QAAQA,CAACpC,KAAK,EAAE;IAC9B,IAAIqC,SAAS,GAAGhB,eAAe,CAACrB,KAAK,EAAEiC,eAAe,EAAEC,eAAe,EAAEF,GAAG,CAAC5B,IAAI,CAAC;IAClF+B,UAAU,GAAGN,eAAe,CAACM,UAAU,EAAE1C,KAAK,EAAEO,KAAK,CAAC;IACtDmC,UAAU,CAAC1C,KAAK,CAAC,GAAG4C,SAAS;IAC7B,OAAOF,UAAU;EACnB,CAAC;AACH;AACA,SAASG,gBAAgBA,CAAC7C,KAAK,EAAEuC,GAAG,EAAE;EACpC,MAAMK,SAAS,GAAGL,GAAG,CAACtC,MAAM,CAACD,KAAK,CAAC,GAAGuC,GAAG,CAAC5B,IAAI;EAC9C,OAAO2B,qBAAqB,CAACtC,KAAK,EAAEuC,GAAG,CAAC,CAACK,SAAS,CAAC;AACrD;AACA,SAASE,oBAAoBA,CAAC9C,KAAK,EAAEuC,GAAG,EAAE;EACxC,MAAMK,SAAS,GAAGL,GAAG,CAACtC,MAAM,CAACD,KAAK,CAAC,GAAGuC,GAAG,CAAC5B,IAAI;EAC9C,OAAO2B,qBAAqB,CAACtC,KAAK,EAAEuC,GAAG,CAAC,CAACK,SAAS,CAAC;AACrD;AACA,SAASG,oBAAoBA,CAAC9C,MAAM,EAAE+C,WAAW,EAAE;EACjD,IAAIC,WAAW,GAAGhD,MAAM,CAACiD,SAAS,CAAE3C,KAAK,IAAKyC,WAAW,GAAGzC,KAAK,GAAG,CAAC,CAAC;EACtE,IAAI0C,WAAW,KAAK,CAAC,EAAE;IACrB,OAAOA,WAAW;EACpB;EACA,IAAIA,WAAW,KAAK,CAAC,CAAC,EAAE;IACtB,OAAOhD,MAAM,CAACI,MAAM,GAAG,CAAC;EAC1B;EACA,IAAI8C,WAAW,GAAGlD,MAAM,CAACgD,WAAW,GAAG,CAAC,CAAC;EACzC,IAAIG,UAAU,GAAGnD,MAAM,CAACgD,WAAW,CAAC;EACpC,IAAIrC,IAAI,CAACqB,GAAG,CAACkB,WAAW,GAAGH,WAAW,CAAC,GAAGpC,IAAI,CAACqB,GAAG,CAACmB,UAAU,GAAGJ,WAAW,CAAC,EAAE;IAC5E,OAAOC,WAAW,GAAG,CAAC;EACxB;EACA,OAAOA,WAAW;AACpB;AACA,SAASI,cAAcA,CAACpD,MAAM,EAAEC,QAAQ,EAAEE,QAAQ,EAAEkD,GAAG,EAAE;EACvD,OAAOrD,MAAM,CAACsD,GAAG,CAAC,CAAChD,KAAK,EAAEP,KAAK,KAAK;IAClC,MAAMe,GAAG,GAAGf,KAAK,KAAK,CAAC,GAAGE,QAAQ,GAAGD,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,GAAGsD,GAAG;IAC5D,MAAMtC,GAAG,GAAGhB,KAAK,KAAKC,MAAM,CAACI,MAAM,GAAG,CAAC,GAAGD,QAAQ,GAAGH,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,GAAGsD,GAAG;IAC5E,OAAO;MAAEvC,GAAG;MAAEC,GAAG;MAAET;IAAM,CAAC;EAC5B,CAAC,CAAC;AACJ;AACA,SAASiD,mBAAmBA,CAACC,MAAM,EAAEC,MAAM,EAAE;EAC3C,MAAMC,KAAK,GAAG;IAAE5C,GAAG,EAAE0C,MAAM,CAAC,CAAC,CAAC;IAAEzC,GAAG,EAAEyC,MAAM,CAAC,CAAC;EAAE,CAAC;EAChD,MAAMG,MAAM,GAAG;IAAE7C,GAAG,EAAE2C,MAAM,CAAC,CAAC,CAAC;IAAE1C,GAAG,EAAE0C,MAAM,CAAC,CAAC;EAAE,CAAC;EACjD,OAAO,SAASG,QAAQA,CAACtD,KAAK,EAAE;IAC9B,IAAIoD,KAAK,CAAC5C,GAAG,KAAK4C,KAAK,CAAC3C,GAAG,IAAI4C,MAAM,CAAC7C,GAAG,KAAK6C,MAAM,CAAC5C,GAAG,EAAE,OAAO4C,MAAM,CAAC7C,GAAG;IAC3E,MAAM+C,KAAK,GAAG,CAACF,MAAM,CAAC5C,GAAG,GAAG4C,MAAM,CAAC7C,GAAG,KAAK4C,KAAK,CAAC3C,GAAG,GAAG2C,KAAK,CAAC5C,GAAG,CAAC;IACjE,OAAO6C,MAAM,CAAC7C,GAAG,GAAG+C,KAAK,IAAIvD,KAAK,GAAGoD,KAAK,CAAC5C,GAAG,CAAC;EACjD,CAAC;AACH;AACA,SAASgD,aAAaA,CAACxD,KAAK,EAAEyD,MAAM,GAAG,CAAC,EAAEC,IAAI,GAAG,EAAE,EAAE;EACnD,MAAMtC,GAAG,GAAGf,IAAI,CAACe,GAAG,CAACsC,IAAI,EAAED,MAAM,CAAC;EAClC,OAAOpD,IAAI,CAACC,KAAK,CAACN,KAAK,GAAGoB,GAAG,CAAC,GAAGA,GAAG;AACtC;AACA,SAASuC,GAAGA,CAAC3D,KAAK,EAAE4D,MAAM,EAAE;EAC1B,OAAO,CAAC5D,KAAK,GAAG4D,MAAM,GAAGA,MAAM,IAAIA,MAAM;AAC3C;AAEA,SAASrD,UAAU,EAAEiC,oBAAoB,EAAE5C,kBAAkB,EAAEJ,kBAAkB,EAAE8C,gBAAgB,EAAE3B,eAAe,EAAE4B,oBAAoB,EAAEpC,eAAe,EAAEO,eAAe,EAAEoC,cAAc,EAAEf,qBAAqB,EAAEkB,mBAAmB,EAAElD,YAAY,EAAEE,YAAY,EAAEC,kBAAkB,EAAEyD,GAAG,EAAE7C,oBAAoB,EAAEO,eAAe,EAAEmC,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}