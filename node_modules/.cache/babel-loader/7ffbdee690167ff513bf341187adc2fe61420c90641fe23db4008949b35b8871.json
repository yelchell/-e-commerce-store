{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/affine-transform.ts\nvar AffineTransform = class _AffineTransform {\n  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {\n    __publicField(this, \"m00\");\n    __publicField(this, \"m01\");\n    __publicField(this, \"m02\");\n    __publicField(this, \"m10\");\n    __publicField(this, \"m11\");\n    __publicField(this, \"m12\");\n    __publicField(this, \"rotate\", (...args) => {\n      return this.prepend(_AffineTransform.rotate(...args));\n    });\n    __publicField(this, \"scale\", (...args) => {\n      return this.prepend(_AffineTransform.scale(...args));\n    });\n    __publicField(this, \"translate\", (...args) => {\n      return this.prepend(_AffineTransform.translate(...args));\n    });\n    this.m00 = m00;\n    this.m01 = m01;\n    this.m02 = m02;\n    this.m10 = m10;\n    this.m11 = m11;\n    this.m12 = m12;\n  }\n  applyTo(point) {\n    const {\n      x,\n      y\n    } = point;\n    const {\n      m00,\n      m01,\n      m02,\n      m10,\n      m11,\n      m12\n    } = this;\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12\n    };\n  }\n  prepend(other) {\n    return new _AffineTransform([this.m00 * other.m00 + this.m01 * other.m10,\n    // m00\n    this.m00 * other.m01 + this.m01 * other.m11,\n    // m01\n    this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n    // m02\n    this.m10 * other.m00 + this.m11 * other.m10,\n    // m10\n    this.m10 * other.m01 + this.m11 * other.m11,\n    // m11\n    this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n    // m12\n    ]);\n  }\n  append(other) {\n    return new _AffineTransform([other.m00 * this.m00 + other.m01 * this.m10,\n    // m00\n    other.m00 * this.m01 + other.m01 * this.m11,\n    // m01\n    other.m00 * this.m02 + other.m01 * this.m12 + other.m02,\n    // m02\n    other.m10 * this.m00 + other.m11 * this.m10,\n    // m10\n    other.m10 * this.m01 + other.m11 * this.m11,\n    // m11\n    other.m10 * this.m02 + other.m11 * this.m12 + other.m12\n    // m12\n    ]);\n  }\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10;\n  }\n  get isInvertible() {\n    const det = this.determinant;\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;\n  }\n  invert() {\n    const det = this.determinant;\n    return new _AffineTransform([this.m11 / det,\n    // m00\n    -this.m01 / det,\n    // m01\n    (this.m01 * this.m12 - this.m11 * this.m02) / det,\n    // m02\n    -this.m10 / det,\n    // m10\n    this.m00 / det,\n    // m11\n    (this.m10 * this.m02 - this.m00 * this.m12) / det\n    // m12\n    ]);\n  }\n  get array() {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];\n  }\n  get float32Array() {\n    return new Float32Array(this.array);\n  }\n  // Static\n  static get identity() {\n    return new _AffineTransform([1, 0, 0, 0, 1, 0]);\n  }\n  static rotate(theta, origin) {\n    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), rotation, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return rotation;\n  }\n  static scale(sx, sy = sx, origin = {\n    x: 0,\n    y: 0\n  }) {\n    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);\n    if (origin.x !== 0 || origin.y !== 0) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), scale, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return scale;\n  }\n  static translate(tx, ty) {\n    return new _AffineTransform([1, 0, tx, 0, 1, ty]);\n  }\n  static multiply(...[first, ...rest]) {\n    if (!first) return _AffineTransform.identity;\n    return rest.reduce((result, item) => result.prepend(item), first);\n  }\n  get a() {\n    return this.m00;\n  }\n  get b() {\n    return this.m10;\n  }\n  get c() {\n    return this.m01;\n  }\n  get d() {\n    return this.m11;\n  }\n  get tx() {\n    return this.m02;\n  }\n  get ty() {\n    return this.m12;\n  }\n  get scaleComponents() {\n    return {\n      x: this.a,\n      y: this.d\n    };\n  }\n  get translationComponents() {\n    return {\n      x: this.tx,\n      y: this.ty\n    };\n  }\n  get skewComponents() {\n    return {\n      x: this.c,\n      y: this.b\n    };\n  }\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n};\n\n// src/align.ts\nfunction hAlign(a, ref, h) {\n  let x = ref.minX;\n  if (h === \"left-inside\") x = ref.minX;\n  if (h === \"left-outside\") x = ref.minX - ref.width;\n  if (h === \"right-inside\") x = ref.maxX - ref.width;\n  if (h === \"right-outside\") x = ref.maxX;\n  if (h === \"center\") x = ref.midX - ref.width / 2;\n  return {\n    ...a,\n    x\n  };\n}\nfunction vAlign(a, ref, v) {\n  let y = ref.minY;\n  if (v === \"top-inside\") y = ref.minY;\n  if (v === \"top-outside\") y = ref.minY - a.height;\n  if (v === \"bottom-inside\") y = ref.maxY - a.height;\n  if (v === \"bottom-outside\") y = ref.maxY;\n  if (v === \"center\") y = ref.midY - a.height / 2;\n  return {\n    ...a,\n    y\n  };\n}\nfunction alignRect(a, ref, options) {\n  const {\n    h,\n    v\n  } = options;\n  return vAlign(hAlign(a, ref, h), ref, v);\n}\n\n// src/clamp.ts\nvar clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);\nvar clampPoint = (position, size, boundaryRect) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);\n  return {\n    x,\n    y\n  };\n};\nvar defaultMinSize = {\n  width: 0,\n  height: 0\n};\nvar defaultMaxSize = {\n  width: Infinity,\n  height: Infinity\n};\nvar clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),\n    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)\n  };\n};\n\n// src/rect.ts\nvar createPoint = (x, y) => ({\n  x,\n  y\n});\nvar subtractPoints = (a, b) => createPoint(a.x - b.x, a.y - b.y);\nvar addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);\nfunction isPoint(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\");\n}\nfunction createRect(r) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = r;\n  const midX = x + width / 2;\n  const midY = y + height / 2;\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY)\n  };\n}\nfunction isRect(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\");\n}\nfunction getRectCenters(v) {\n  const top = createPoint(v.midX, v.minY);\n  const right = createPoint(v.maxX, v.midY);\n  const bottom = createPoint(v.midX, v.maxY);\n  const left = createPoint(v.minX, v.midY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectCorners(v) {\n  const top = createPoint(v.minX, v.minY);\n  const right = createPoint(v.maxX, v.minY);\n  const bottom = createPoint(v.maxX, v.maxY);\n  const left = createPoint(v.minX, v.maxY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectEdges(v) {\n  const c = getRectCorners(v);\n  const top = [c.top, c.right];\n  const right = [c.right, c.bottom];\n  const bottom = [c.left, c.bottom];\n  const left = [c.top, c.left];\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\n\n// src/intersection.ts\nfunction intersects(a, b) {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;\n}\nfunction intersection(a, b) {\n  const x = Math.max(a.x, b.x);\n  const y = Math.max(a.y, b.y);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  return createRect({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y\n  });\n}\nfunction collisions(a, b) {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX\n  };\n}\n\n// src/distance.ts\nfunction distance(a, b = {\n  x: 0,\n  y: 0\n}) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\nfunction distanceFromPoint(r, p) {\n  let x = 0;\n  let y = 0;\n  if (p.x < r.x) x = r.x - p.x;else if (p.x > r.maxX) x = p.x - r.maxX;\n  if (p.y < r.y) y = r.y - p.y;else if (p.y > r.maxY) y = p.y - r.maxY;\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceFromRect(a, b) {\n  if (intersects(a, b)) return {\n    x: 0,\n    y: 0,\n    value: 0\n  };\n  const left = a.x < b.x ? a : b;\n  const right = b.x < a.x ? a : b;\n  const upper = a.y < b.y ? a : b;\n  const lower = b.y < a.y ? a : b;\n  let x = left.x === right.x ? 0 : right.x - left.maxX;\n  x = Math.max(0, x);\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;\n  y = Math.max(0, y);\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceBtwEdges(a, b) {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY\n  };\n}\n\n// src/closest.ts\nfunction closest(...pts) {\n  return a => {\n    const ds = pts.map(b => distance(b, a));\n    const c = Math.min.apply(Math, ds);\n    return pts[ds.indexOf(c)];\n  };\n}\nfunction closestSideToRect(ref, r) {\n  if (r.maxX <= ref.minX) return \"left\";\n  if (r.minX >= ref.maxX) return \"right\";\n  if (r.maxY <= ref.minY) return \"top\";\n  if (r.minY >= ref.maxY) return \"bottom\";\n  return \"left\";\n}\nfunction closestSideToPoint(ref, p) {\n  const {\n    x,\n    y\n  } = p;\n  const dl = x - ref.minX;\n  const dr = ref.maxX - x;\n  const dt = y - ref.minY;\n  const db = ref.maxY - y;\n  let closest2 = dl;\n  let side = \"left\";\n  if (dr < closest2) {\n    closest2 = dr;\n    side = \"right\";\n  }\n  if (dt < closest2) {\n    closest2 = dt;\n    side = \"top\";\n  }\n  if (db < closest2) {\n    side = \"bottom\";\n  }\n  return side;\n}\n\n// src/constrain.ts\nvar constrainRect = (rect, boundary) => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height)\n  };\n};\n\n// src/contains.ts\nfunction containsPoint(r, p) {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;\n}\nfunction containsRect(a, b) {\n  return Object.values(getRectCorners(b)).every(c => containsPoint(a, c));\n}\nfunction contains(r, v) {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);\n}\n\n// src/equality.ts\nvar isSizeEqual = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar isPointEqual = (a, b) => {\n  return a.x === b.x && a.y === b.y;\n};\nvar isRectEqual = (a, b) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b);\n};\n\n// src/from-element.ts\nvar styleCache = /* @__PURE__ */new WeakMap();\nfunction getCacheComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window;\n    styleCache.set(el, win.getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\nfunction getElementRect(el, opts = {}) {\n  return createRect(getClientRect(el, opts));\n}\nfunction getClientRect(el, opts = {}) {\n  const {\n    excludeScrollbar = false,\n    excludeBorders = false\n  } = opts;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = el.getBoundingClientRect();\n  const r = {\n    x,\n    y,\n    width,\n    height\n  };\n  const style = getCacheComputedStyle(el);\n  const {\n    borderLeftWidth,\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth);\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth);\n  if (excludeBorders) {\n    r.width -= borderXWidth;\n    r.height -= borderYWidth;\n    r.x += px(borderLeftWidth);\n    r.y += px(borderTopWidth);\n  }\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;\n    r.width -= scrollbarWidth;\n    r.height -= scrollbarHeight;\n  }\n  return r;\n}\nvar px = v => parseFloat(v.replace(\"px\", \"\"));\nvar sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);\n\n// src/from-points.ts\nfunction getRectFromPoints(...pts) {\n  const xs = pts.map(p => p.x);\n  const ys = pts.map(p => p.y);\n  const x = Math.min(...xs);\n  const y = Math.min(...ys);\n  const width = Math.max(...xs) - x;\n  const height = Math.max(...ys) - y;\n  return createRect({\n    x,\n    y,\n    width,\n    height\n  });\n}\n\n// src/union.ts\nvar {\n  min,\n  max\n} = Math;\nfunction union(...rs) {\n  const pMin = {\n    x: min(...rs.map(r => r.minX)),\n    y: min(...rs.map(r => r.minY))\n  };\n  const pMax = {\n    x: max(...rs.map(r => r.maxX)),\n    y: max(...rs.map(r => r.maxY))\n  };\n  return getRectFromPoints(pMin, pMax);\n}\n\n// src/from-range.ts\nfunction fromRange(range) {\n  let rs = [];\n  const rects = Array.from(range.getClientRects());\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect));\n    return union.apply(void 0, rs);\n  }\n  let start = range.startContainer;\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode;\n  }\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start);\n    rs.push({\n      ...r,\n      x: r.maxX,\n      width: 0\n    });\n  }\n  return union.apply(void 0, rs);\n}\n\n// src/from-rotation.ts\nfunction toRad(d) {\n  return d % 360 * Math.PI / 180;\n}\nfunction rotate(a, d, c) {\n  const r = toRad(d);\n  const sin = Math.sin(r);\n  const cos = Math.cos(r);\n  const x = a.x - c.x;\n  const y = a.y - c.y;\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos\n  };\n}\nfunction getRotationRect(r, deg) {\n  const rr = Object.values(getRectCorners(r)).map(p => rotate(p, deg, r.center));\n  const xs = rr.map(p => p.x);\n  const ys = rr.map(p => p.y);\n  const minX = Math.min(...xs);\n  const minY = Math.min(...ys);\n  const maxX = Math.max(...xs);\n  const maxY = Math.max(...ys);\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  });\n}\n\n// src/from-window.ts\nfunction getWindowRect(win, opts = {}) {\n  return createRect(getViewportRect(win, opts));\n}\nfunction getViewportRect(win, opts) {\n  const {\n    excludeScrollbar = false\n  } = opts;\n  const {\n    innerWidth,\n    innerHeight,\n    document: doc,\n    visualViewport\n  } = win;\n  const width = visualViewport?.width || innerWidth;\n  const height = visualViewport?.height || innerHeight;\n  const rect = {\n    x: 0,\n    y: 0,\n    width,\n    height\n  };\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;\n    rect.width -= scrollbarWidth;\n    rect.height -= scrollbarHeight;\n  }\n  return rect;\n}\n\n// src/operations.ts\nvar isSymmetric = v => \"dx\" in v || \"dy\" in v;\nfunction inset(r, i) {\n  const v = isSymmetric(i) ? {\n    left: i.dx,\n    right: i.dx,\n    top: i.dy,\n    bottom: i.dy\n  } : i;\n  const {\n    top = 0,\n    right = 0,\n    bottom = 0,\n    left = 0\n  } = v;\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom\n  });\n}\nfunction expand(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shrink(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shift(r, o) {\n  const {\n    x = 0,\n    y = 0\n  } = o;\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height\n  });\n}\n\n// src/polygon.ts\nfunction getElementPolygon(rectValue, placement) {\n  const rect = createRect(rectValue);\n  const {\n    top,\n    right,\n    left,\n    bottom\n  } = getRectCorners(rect);\n  const [base] = placement.split(\"-\");\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom]\n  }[base];\n}\nfunction isPointInPolygon(polygon, point) {\n  const {\n    x,\n    y\n  } = point;\n  let c = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      c = !c;\n    }\n  }\n  return c;\n}\nfunction createPolygonElement() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\"\n  });\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\nfunction debugPolygon(polygon) {\n  const el = createPolygonElement();\n  const points = polygon.map(point => `${point.x},${point.y}`).join(\" \");\n  el.setAttribute(\"points\", points);\n  return () => {\n    el.remove();\n  };\n}\n\n// src/compass.ts\nvar compassDirectionMap = {\n  n: {\n    x: 0.5,\n    y: 0\n  },\n  ne: {\n    x: 1,\n    y: 0\n  },\n  e: {\n    x: 1,\n    y: 0.5\n  },\n  se: {\n    x: 1,\n    y: 1\n  },\n  s: {\n    x: 0.5,\n    y: 1\n  },\n  sw: {\n    x: 0,\n    y: 1\n  },\n  w: {\n    x: 0,\n    y: 0.5\n  },\n  nw: {\n    x: 0,\n    y: 0\n  }\n};\nvar oppositeDirectionMap = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\"\n};\n\n// src/resize.ts\nvar {\n  sign,\n  abs,\n  min: min2\n} = Math;\nfunction getRectExtentPoint(rect, direction) {\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    midX,\n    midY\n  } = rect;\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX;\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY;\n  return {\n    x,\n    y\n  };\n}\nfunction getOppositeDirection(direction) {\n  return oppositeDirectionMap[direction];\n}\nfunction resizeRect(rect, offset, direction, opts) {\n  const {\n    scalingOriginMode,\n    lockAspectRatio\n  } = opts;\n  const extent = getRectExtentPoint(rect, direction);\n  const oppositeDirection = getOppositeDirection(direction);\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);\n  if (scalingOriginMode === \"center\") {\n    offset = {\n      x: offset.x * 2,\n      y: offset.y * 2\n    };\n  }\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y\n  };\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1\n  };\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y\n  };\n  const scaleX = multiplier.x * newSize.width / rect.width;\n  const scaleY = multiplier.y * newSize.height / rect.height;\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;\n  const scale = lockAspectRatio ? {\n    x: largestMagnitude,\n    y: largestMagnitude\n  } : {\n    x: extent.x === oppositeExtent.x ? 1 : scaleX,\n    y: extent.y === oppositeExtent.y ? 1 : scaleY\n  };\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y);\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1;\n  }\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x);\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1;\n  }\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);\n    case \"center\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, {\n        x: rect.midX,\n        y: rect.midY\n      }), false);\n  }\n}\nfunction createRectFromPoints(initialPoint, finalPoint, normalized = true) {\n  if (normalized) {\n    return {\n      x: min2(finalPoint.x, initialPoint.x),\n      y: min2(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y)\n    };\n  }\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y\n  };\n}\nfunction transformRect(rect, transform, normalized = true) {\n  const p1 = transform.applyTo({\n    x: rect.minX,\n    y: rect.minY\n  });\n  const p2 = transform.applyTo({\n    x: rect.maxX,\n    y: rect.maxY\n  });\n  return createRectFromPoints(p1, p2, normalized);\n}\nexport { AffineTransform, addPoints, alignRect, clampPoint, clampSize, closest, closestSideToPoint, closestSideToRect, collisions, constrainRect, contains, containsPoint, containsRect, createPoint, createRect, debugPolygon, distance, distanceBtwEdges, distanceFromPoint, distanceFromRect, expand, fromRange, getElementPolygon, getElementRect, getRectCenters, getRectCorners, getRectEdges, getRectFromPoints, getRotationRect, getViewportRect, getWindowRect, inset, intersection, intersects, isPoint, isPointEqual, isPointInPolygon, isRect, isRectEqual, isSizeEqual, isSymmetric, resizeRect, rotate, shift, shrink, subtractPoints, toRad, union };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","AffineTransform","_AffineTransform","constructor","m00","m01","m02","m10","m11","m12","args","prepend","rotate","scale","translate","applyTo","point","x","y","other","append","determinant","isInvertible","det","isFinite","invert","array","float32Array","Float32Array","identity","theta","origin","rotation","Math","cos","sin","multiply","sx","sy","tx","ty","first","rest","reduce","result","item","a","b","c","d","scaleComponents","translationComponents","skewComponents","toString","hAlign","ref","h","minX","width","maxX","midX","vAlign","v","minY","height","maxY","midY","alignRect","options","clamp","min3","max2","min","max","clampPoint","position","size","boundaryRect","defaultMinSize","defaultMaxSize","Infinity","clampSize","minSize","maxSize","createPoint","subtractPoints","addPoints","isPoint","Reflect","has","createRect","r","center","isRect","getRectCenters","top","right","bottom","left","getRectCorners","getRectEdges","intersects","intersection","x2","y2","collisions","distance","sqrt","pow","distanceFromPoint","p","distanceFromRect","upper","lower","distanceBtwEdges","closest","pts","ds","map","apply","indexOf","closestSideToRect","closestSideToPoint","dl","dr","dt","db","closest2","side","constrainRect","rect","boundary","containsPoint","containsRect","values","every","contains","isSizeEqual","isPointEqual","isRectEqual","styleCache","WeakMap","getCacheComputedStyle","el","win","ownerDocument","defaultView","window","set","getComputedStyle","get","getElementRect","opts","getClientRect","excludeScrollbar","excludeBorders","getBoundingClientRect","style","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderXWidth","sum","borderYWidth","px","scrollbarWidth","offsetWidth","clientWidth","scrollbarHeight","offsetHeight","clientHeight","parseFloat","replace","vals","sum2","getRectFromPoints","xs","ys","union","rs","pMin","pMax","fromRange","range","rects","Array","from","getClientRects","length","concat","start","startContainer","nodeType","Node","TEXT_NODE","parentNode","HTMLElement","push","toRad","PI","getRotationRect","deg","rr","getWindowRect","getViewportRect","innerWidth","innerHeight","document","doc","visualViewport","documentElement","isSymmetric","inset","i","dx","dy","expand","shrink","shift","o","getElementPolygon","rectValue","placement","base","split","isPointInPolygon","polygon","j","xi","yi","xj","yj","createPolygonElement","id","existingPolygon","getElementById","svg","createElementNS","assign","opacity","pointerEvents","fill","setAttribute","appendChild","body","debugPolygon","points","join","remove","compassDirectionMap","n","ne","e","se","s","sw","w","nw","oppositeDirectionMap","sign","abs","min2","getRectExtentPoint","direction","includes","getOppositeDirection","resizeRect","offset","scalingOriginMode","lockAspectRatio","extent","oppositeDirection","oppositeExtent","newExtent","multiplier","newSize","scaleX","scaleY","largestMagnitude","transformRect","createRectFromPoints","initialPoint","finalPoint","normalized","transform","p1","p2"],"sources":["D:/assignment/e_commerce/ecommerce-product-page/node_modules/@zag-js/rect-utils/dist/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/affine-transform.ts\nvar AffineTransform = class _AffineTransform {\n  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {\n    __publicField(this, \"m00\");\n    __publicField(this, \"m01\");\n    __publicField(this, \"m02\");\n    __publicField(this, \"m10\");\n    __publicField(this, \"m11\");\n    __publicField(this, \"m12\");\n    __publicField(this, \"rotate\", (...args) => {\n      return this.prepend(_AffineTransform.rotate(...args));\n    });\n    __publicField(this, \"scale\", (...args) => {\n      return this.prepend(_AffineTransform.scale(...args));\n    });\n    __publicField(this, \"translate\", (...args) => {\n      return this.prepend(_AffineTransform.translate(...args));\n    });\n    this.m00 = m00;\n    this.m01 = m01;\n    this.m02 = m02;\n    this.m10 = m10;\n    this.m11 = m11;\n    this.m12 = m12;\n  }\n  applyTo(point) {\n    const { x, y } = point;\n    const { m00, m01, m02, m10, m11, m12 } = this;\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12\n    };\n  }\n  prepend(other) {\n    return new _AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10,\n      // m00\n      this.m00 * other.m01 + this.m01 * other.m11,\n      // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n      // m02\n      this.m10 * other.m00 + this.m11 * other.m10,\n      // m10\n      this.m10 * other.m01 + this.m11 * other.m11,\n      // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n      // m12\n    ]);\n  }\n  append(other) {\n    return new _AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10,\n      // m00\n      other.m00 * this.m01 + other.m01 * this.m11,\n      // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02,\n      // m02\n      other.m10 * this.m00 + other.m11 * this.m10,\n      // m10\n      other.m10 * this.m01 + other.m11 * this.m11,\n      // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12\n      // m12\n    ]);\n  }\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10;\n  }\n  get isInvertible() {\n    const det = this.determinant;\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;\n  }\n  invert() {\n    const det = this.determinant;\n    return new _AffineTransform([\n      this.m11 / det,\n      // m00\n      -this.m01 / det,\n      // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det,\n      // m02\n      -this.m10 / det,\n      // m10\n      this.m00 / det,\n      // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det\n      // m12\n    ]);\n  }\n  get array() {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];\n  }\n  get float32Array() {\n    return new Float32Array(this.array);\n  }\n  // Static\n  static get identity() {\n    return new _AffineTransform([1, 0, 0, 0, 1, 0]);\n  }\n  static rotate(theta, origin) {\n    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return _AffineTransform.multiply(\n        _AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        _AffineTransform.translate(-origin.x, -origin.y)\n      );\n    }\n    return rotation;\n  }\n  static scale(sx, sy = sx, origin = { x: 0, y: 0 }) {\n    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);\n    if (origin.x !== 0 || origin.y !== 0) {\n      return _AffineTransform.multiply(\n        _AffineTransform.translate(origin.x, origin.y),\n        scale,\n        _AffineTransform.translate(-origin.x, -origin.y)\n      );\n    }\n    return scale;\n  }\n  static translate(tx, ty) {\n    return new _AffineTransform([1, 0, tx, 0, 1, ty]);\n  }\n  static multiply(...[first, ...rest]) {\n    if (!first) return _AffineTransform.identity;\n    return rest.reduce((result, item) => result.prepend(item), first);\n  }\n  get a() {\n    return this.m00;\n  }\n  get b() {\n    return this.m10;\n  }\n  get c() {\n    return this.m01;\n  }\n  get d() {\n    return this.m11;\n  }\n  get tx() {\n    return this.m02;\n  }\n  get ty() {\n    return this.m12;\n  }\n  get scaleComponents() {\n    return { x: this.a, y: this.d };\n  }\n  get translationComponents() {\n    return { x: this.tx, y: this.ty };\n  }\n  get skewComponents() {\n    return { x: this.c, y: this.b };\n  }\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n};\n\n// src/align.ts\nfunction hAlign(a, ref, h) {\n  let x = ref.minX;\n  if (h === \"left-inside\") x = ref.minX;\n  if (h === \"left-outside\") x = ref.minX - ref.width;\n  if (h === \"right-inside\") x = ref.maxX - ref.width;\n  if (h === \"right-outside\") x = ref.maxX;\n  if (h === \"center\") x = ref.midX - ref.width / 2;\n  return { ...a, x };\n}\nfunction vAlign(a, ref, v) {\n  let y = ref.minY;\n  if (v === \"top-inside\") y = ref.minY;\n  if (v === \"top-outside\") y = ref.minY - a.height;\n  if (v === \"bottom-inside\") y = ref.maxY - a.height;\n  if (v === \"bottom-outside\") y = ref.maxY;\n  if (v === \"center\") y = ref.midY - a.height / 2;\n  return { ...a, y };\n}\nfunction alignRect(a, ref, options) {\n  const { h, v } = options;\n  return vAlign(hAlign(a, ref, h), ref, v);\n}\n\n// src/clamp.ts\nvar clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);\nvar clampPoint = (position, size, boundaryRect) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);\n  return { x, y };\n};\nvar defaultMinSize = {\n  width: 0,\n  height: 0\n};\nvar defaultMaxSize = {\n  width: Infinity,\n  height: Infinity\n};\nvar clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),\n    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)\n  };\n};\n\n// src/rect.ts\nvar createPoint = (x, y) => ({ x, y });\nvar subtractPoints = (a, b) => createPoint(a.x - b.x, a.y - b.y);\nvar addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);\nfunction isPoint(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\");\n}\nfunction createRect(r) {\n  const { x, y, width, height } = r;\n  const midX = x + width / 2;\n  const midY = y + height / 2;\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY)\n  };\n}\nfunction isRect(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\");\n}\nfunction getRectCenters(v) {\n  const top = createPoint(v.midX, v.minY);\n  const right = createPoint(v.maxX, v.midY);\n  const bottom = createPoint(v.midX, v.maxY);\n  const left = createPoint(v.minX, v.midY);\n  return { top, right, bottom, left };\n}\nfunction getRectCorners(v) {\n  const top = createPoint(v.minX, v.minY);\n  const right = createPoint(v.maxX, v.minY);\n  const bottom = createPoint(v.maxX, v.maxY);\n  const left = createPoint(v.minX, v.maxY);\n  return { top, right, bottom, left };\n}\nfunction getRectEdges(v) {\n  const c = getRectCorners(v);\n  const top = [c.top, c.right];\n  const right = [c.right, c.bottom];\n  const bottom = [c.left, c.bottom];\n  const left = [c.top, c.left];\n  return { top, right, bottom, left };\n}\n\n// src/intersection.ts\nfunction intersects(a, b) {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;\n}\nfunction intersection(a, b) {\n  const x = Math.max(a.x, b.x);\n  const y = Math.max(a.y, b.y);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  return createRect({ x, y, width: x2 - x, height: y2 - y });\n}\nfunction collisions(a, b) {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX\n  };\n}\n\n// src/distance.ts\nfunction distance(a, b = { x: 0, y: 0 }) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\nfunction distanceFromPoint(r, p) {\n  let x = 0;\n  let y = 0;\n  if (p.x < r.x) x = r.x - p.x;\n  else if (p.x > r.maxX) x = p.x - r.maxX;\n  if (p.y < r.y) y = r.y - p.y;\n  else if (p.y > r.maxY) y = p.y - r.maxY;\n  return { x, y, value: distance({ x, y }) };\n}\nfunction distanceFromRect(a, b) {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 };\n  const left = a.x < b.x ? a : b;\n  const right = b.x < a.x ? a : b;\n  const upper = a.y < b.y ? a : b;\n  const lower = b.y < a.y ? a : b;\n  let x = left.x === right.x ? 0 : right.x - left.maxX;\n  x = Math.max(0, x);\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;\n  y = Math.max(0, y);\n  return { x, y, value: distance({ x, y }) };\n}\nfunction distanceBtwEdges(a, b) {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY\n  };\n}\n\n// src/closest.ts\nfunction closest(...pts) {\n  return (a) => {\n    const ds = pts.map((b) => distance(b, a));\n    const c = Math.min.apply(Math, ds);\n    return pts[ds.indexOf(c)];\n  };\n}\nfunction closestSideToRect(ref, r) {\n  if (r.maxX <= ref.minX) return \"left\";\n  if (r.minX >= ref.maxX) return \"right\";\n  if (r.maxY <= ref.minY) return \"top\";\n  if (r.minY >= ref.maxY) return \"bottom\";\n  return \"left\";\n}\nfunction closestSideToPoint(ref, p) {\n  const { x, y } = p;\n  const dl = x - ref.minX;\n  const dr = ref.maxX - x;\n  const dt = y - ref.minY;\n  const db = ref.maxY - y;\n  let closest2 = dl;\n  let side = \"left\";\n  if (dr < closest2) {\n    closest2 = dr;\n    side = \"right\";\n  }\n  if (dt < closest2) {\n    closest2 = dt;\n    side = \"top\";\n  }\n  if (db < closest2) {\n    side = \"bottom\";\n  }\n  return side;\n}\n\n// src/constrain.ts\nvar constrainRect = (rect, boundary) => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height)\n  };\n};\n\n// src/contains.ts\nfunction containsPoint(r, p) {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;\n}\nfunction containsRect(a, b) {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c));\n}\nfunction contains(r, v) {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);\n}\n\n// src/equality.ts\nvar isSizeEqual = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar isPointEqual = (a, b) => {\n  return a.x === b.x && a.y === b.y;\n};\nvar isRectEqual = (a, b) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b);\n};\n\n// src/from-element.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getCacheComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window;\n    styleCache.set(el, win.getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\nfunction getElementRect(el, opts = {}) {\n  return createRect(getClientRect(el, opts));\n}\nfunction getClientRect(el, opts = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts;\n  const { x, y, width, height } = el.getBoundingClientRect();\n  const r = { x, y, width, height };\n  const style = getCacheComputedStyle(el);\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth);\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth);\n  if (excludeBorders) {\n    r.width -= borderXWidth;\n    r.height -= borderYWidth;\n    r.x += px(borderLeftWidth);\n    r.y += px(borderTopWidth);\n  }\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;\n    r.width -= scrollbarWidth;\n    r.height -= scrollbarHeight;\n  }\n  return r;\n}\nvar px = (v) => parseFloat(v.replace(\"px\", \"\"));\nvar sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);\n\n// src/from-points.ts\nfunction getRectFromPoints(...pts) {\n  const xs = pts.map((p) => p.x);\n  const ys = pts.map((p) => p.y);\n  const x = Math.min(...xs);\n  const y = Math.min(...ys);\n  const width = Math.max(...xs) - x;\n  const height = Math.max(...ys) - y;\n  return createRect({ x, y, width, height });\n}\n\n// src/union.ts\nvar { min, max } = Math;\nfunction union(...rs) {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY))\n  };\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY))\n  };\n  return getRectFromPoints(pMin, pMax);\n}\n\n// src/from-range.ts\nfunction fromRange(range) {\n  let rs = [];\n  const rects = Array.from(range.getClientRects());\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect));\n    return union.apply(void 0, rs);\n  }\n  let start = range.startContainer;\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode;\n  }\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start);\n    rs.push({ ...r, x: r.maxX, width: 0 });\n  }\n  return union.apply(void 0, rs);\n}\n\n// src/from-rotation.ts\nfunction toRad(d) {\n  return d % 360 * Math.PI / 180;\n}\nfunction rotate(a, d, c) {\n  const r = toRad(d);\n  const sin = Math.sin(r);\n  const cos = Math.cos(r);\n  const x = a.x - c.x;\n  const y = a.y - c.y;\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos\n  };\n}\nfunction getRotationRect(r, deg) {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center));\n  const xs = rr.map((p) => p.x);\n  const ys = rr.map((p) => p.y);\n  const minX = Math.min(...xs);\n  const minY = Math.min(...ys);\n  const maxX = Math.max(...xs);\n  const maxY = Math.max(...ys);\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  });\n}\n\n// src/from-window.ts\nfunction getWindowRect(win, opts = {}) {\n  return createRect(getViewportRect(win, opts));\n}\nfunction getViewportRect(win, opts) {\n  const { excludeScrollbar = false } = opts;\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win;\n  const width = visualViewport?.width || innerWidth;\n  const height = visualViewport?.height || innerHeight;\n  const rect = { x: 0, y: 0, width, height };\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;\n    rect.width -= scrollbarWidth;\n    rect.height -= scrollbarHeight;\n  }\n  return rect;\n}\n\n// src/operations.ts\nvar isSymmetric = (v) => \"dx\" in v || \"dy\" in v;\nfunction inset(r, i) {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i;\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v;\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom\n  });\n}\nfunction expand(r, v) {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v;\n  return inset(r, value);\n}\nfunction shrink(r, v) {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v;\n  return inset(r, value);\n}\nfunction shift(r, o) {\n  const { x = 0, y = 0 } = o;\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height\n  });\n}\n\n// src/polygon.ts\nfunction getElementPolygon(rectValue, placement) {\n  const rect = createRect(rectValue);\n  const { top, right, left, bottom } = getRectCorners(rect);\n  const [base] = placement.split(\"-\");\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom]\n  }[base];\n}\nfunction isPointInPolygon(polygon, point) {\n  const { x, y } = point;\n  let c = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      c = !c;\n    }\n  }\n  return c;\n}\nfunction createPolygonElement() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\"\n  });\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\nfunction debugPolygon(polygon) {\n  const el = createPolygonElement();\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \");\n  el.setAttribute(\"points\", points);\n  return () => {\n    el.remove();\n  };\n}\n\n// src/compass.ts\nvar compassDirectionMap = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 }\n};\nvar oppositeDirectionMap = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\"\n};\n\n// src/resize.ts\nvar { sign, abs, min: min2 } = Math;\nfunction getRectExtentPoint(rect, direction) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect;\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX;\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY;\n  return { x, y };\n}\nfunction getOppositeDirection(direction) {\n  return oppositeDirectionMap[direction];\n}\nfunction resizeRect(rect, offset, direction, opts) {\n  const { scalingOriginMode, lockAspectRatio } = opts;\n  const extent = getRectExtentPoint(rect, direction);\n  const oppositeDirection = getOppositeDirection(direction);\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 };\n  }\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y\n  };\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1\n  };\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y\n  };\n  const scaleX = multiplier.x * newSize.width / rect.width;\n  const scaleY = multiplier.y * newSize.height / rect.height;\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;\n  const scale = lockAspectRatio ? { x: largestMagnitude, y: largestMagnitude } : {\n    x: extent.x === oppositeExtent.x ? 1 : scaleX,\n    y: extent.y === oppositeExtent.y ? 1 : scaleY\n  };\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y);\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1;\n  }\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x);\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1;\n  }\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY\n        }),\n        false\n      );\n  }\n}\nfunction createRectFromPoints(initialPoint, finalPoint, normalized = true) {\n  if (normalized) {\n    return {\n      x: min2(finalPoint.x, initialPoint.x),\n      y: min2(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y)\n    };\n  }\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y\n  };\n}\nfunction transformRect(rect, transform, normalized = true) {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY });\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY });\n  return createRectFromPoints(p1, p2, normalized);\n}\n\nexport { AffineTransform, addPoints, alignRect, clampPoint, clampSize, closest, closestSideToPoint, closestSideToRect, collisions, constrainRect, contains, containsPoint, containsRect, createPoint, createRect, debugPolygon, distance, distanceBtwEdges, distanceFromPoint, distanceFromRect, expand, fromRange, getElementPolygon, getElementRect, getRectCenters, getRectCorners, getRectEdges, getRectFromPoints, getRotationRect, getViewportRect, getWindowRect, inset, intersection, intersects, isPoint, isPointEqual, isPointInPolygon, isRect, isRectEqual, isSizeEqual, isSymmetric, resizeRect, rotate, shift, shrink, subtractPoints, toRad, union };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}